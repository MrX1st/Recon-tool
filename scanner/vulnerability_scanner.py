import requests
import sqlite3
import logging
import os
import json
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

logger = logging.getLogger(__name__)
DB_PATH = os.path.join(os.path.dirname(os.path.dirname(__file__)), "data", "assets.db")

class VulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        # Using free vulnerability databases
        self.vulndb_api = "https://vuldb.com/api/v1/"
        self.nvd_api = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    
    def detect_service_version(self, ip, port):
        """Attempt to detect service version through banner grabbing"""
        try:
            import socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((ip, port))
            
            # Send HTTP request for web services
            if port in [80, 443, 8080, 8443]:
                request = "GET / HTTP/1.1\r\nHost: {}\r\n\r\n".format(ip)
                sock.send(request.encode())
                
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            # Parse banner for version information
            service_info = self.parse_banner(banner, port)
            return service_info
            
        except Exception as e:
            logger.debug(f"Banner grab failed for {ip}:{port}: {e}")
            return None
    
    def parse_banner(self, banner, port):
        """Parse banner to extract service and version information"""
        service_info = {'service': 'unknown', 'version': '', 'banner': banner[:200]}
        
        # Common service signatures
        if 'Server:' in banner:
            server_line = [line for line in banner.split('\n') if 'Server:' in line]
            if server_line:
                server_info = server_line[0].split('Server:')[1].strip()
                service_info['service'] = server_info.split('/')[0].strip()
                if '/' in server_info:
                    service_info['version'] = server_info.split('/')[1].split(' ')[0]
        
        # SSH detection
        if banner.startswith('SSH-'):
            parts = banner.split('-')
            if len(parts) >= 3:
                service_info['service'] = 'SSH'
                service_info['version'] = parts[1]
        
        # FTP detection
        if '220' in banner and 'FTP' in banner:
            service_info['service'] = 'FTP'
            # Try to extract version
            words = banner.split()
            for i, word in enumerate(words):
                if any(char.isdigit() for char in word) and '.' in word:
                    service_info['version'] = word
                    break
        
        return service_info
    
    def search_vulnerabilities(self, service, version):
        """Search for known vulnerabilities"""
        vulnerabilities = []
        
        # Search using CVE database (free but limited)
        try:
            # Use a simple keyword search approach
            search_term = f"{service} {version}".strip()
            if search_term and search_term != 'unknown':
                # This is a simplified approach - in production you'd want more sophisticated matching
                vulns = self.search_cve_database(search_term)
                vulnerabilities.extend(vulns)
                
        except Exception as e:
            logger.error(f"Vulnerability search error: {e}")
        
        return vulnerabilities
    
    def search_cve_database(self, search_term):
        """Search CVE database for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Using NVD API (free but rate limited)
            params = {
                'keywordSearch': search_term,
                'resultsPerPage': 5  # Limit results
            }
            
            response = self.session.get(self.nvd_api, params=params, timeout=15)
            if response.status_code == 200:
                data = response.json()
                
                for vuln in data.get('vulnerabilities', []):
                    cve_data = vuln.get('cve', {})
                    cve_id = cve_data.get('id', '')
                    description = ''
                    
                    descriptions = cve_data.get('descriptions', [])
                    if descriptions:
                        description = descriptions[0].get('value', '')
                    
                    # Get CVSS score if available
                    cvss_score = 0
                    metrics = cve_data.get('metrics', {})
                    if 'cvssMetricV31' in metrics:
                        cvss_score = metrics['cvssMetricV31'][0].get('cvssData', {}).get('baseScore', 0)
                    elif 'cvssMetricV2' in metrics:
                        cvss_score = metrics['cvssMetricV2'][0].get('cvssData', {}).get('baseScore', 0)
                    
                    vulnerabilities.append({
                        'cve_id': cve_id,
                        'description': description,
                        'cvss_score': cvss_score,
                        'severity': self.get_severity_from_score(cvss_score)
                    })
            
            time.sleep(2)  # Rate limiting for NVD API
            
        except Exception as e:
            logger.error(f"CVE database search error: {e}")
        
        return vulnerabilities
    
    def get_severity_from_score(self, score):
        """Convert CVSS score to severity level"""
        if score >= 9.0:
            return 'CRITICAL'
        elif score >= 7.0:
            return 'HIGH'
        elif score >= 4.0:
            return 'MEDIUM'
        elif score > 0:
            return 'LOW'
        else:
            return 'INFO'

def scan_for_vulnerabilities(ip, ports):
    """Scan for vulnerabilities on given IP and ports"""
    scanner = VulnerabilityScanner()
    results = []
    
    for port in ports:
        # Detect service
        service_info = scanner.detect_service_version(ip, port)
        
        if service_info and service_info['service'] != 'unknown':
            # Search for vulnerabilities
            vulnerabilities = scanner.search_vulnerabilities(
                service_info['service'], 
                service_info['version']
            )
            
            results.append({
                'ip': ip,
                'port': port,
                'service': service_info['service'],
                'version': service_info['version'],
                'banner': service_info['banner'],
                'vulnerabilities': vulnerabilities
            })
    
    return results

def store_vulnerability_data(vulnerability_results):
    """Store vulnerability scan results in database"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    for result in vulnerability_results:
        # Store service information
        c.execute("""
            UPDATE ports SET service = ?, version = ?, banner = ?
            WHERE asset_id = (SELECT id FROM assets WHERE ip = ?) AND port = ?
        """, (
            result['service'], result['version'], result['banner'],
            result['ip'], result['port']
        ))
        
        # Store vulnerabilities
        for vuln in result['vulnerabilities']:
            c.execute("""
                INSERT OR REPLACE INTO vulnerabilities
                (ip, port, cve_id, description, cvss_score, severity, last_updated)
                VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            """, (
                result['ip'], result['port'], vuln['cve_id'],
                vuln['description'], vuln['cvss_score'], vuln['severity']
            ))
    
    conn.commit()
    conn.close()
